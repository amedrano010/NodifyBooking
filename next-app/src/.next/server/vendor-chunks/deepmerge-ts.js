"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/deepmerge-ts";
exports.ids = ["vendor-chunks/deepmerge-ts"];
exports.modules = {

/***/ "(ssr)/../node_modules/deepmerge-ts/dist/index.mjs":
/*!***************************************************!*\
  !*** ../node_modules/deepmerge-ts/dist/index.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deepmerge: () => (/* binding */ deepmerge),\n/* harmony export */   deepmergeCustom: () => (/* binding */ deepmergeCustom),\n/* harmony export */   deepmergeInto: () => (/* binding */ deepmergeInto),\n/* harmony export */   deepmergeIntoCustom: () => (/* binding */ deepmergeIntoCustom),\n/* harmony export */   getKeys: () => (/* binding */ getKeys),\n/* harmony export */   getObjectType: () => (/* binding */ getObjectType),\n/* harmony export */   objectHasProperty: () => (/* binding */ objectHasProperty)\n/* harmony export */ });\n/**\n * Special values that tell deepmerge to perform a certain action.\n */\nconst actions = {\n    defaultMerge: Symbol(\"deepmerge-ts: default merge\"),\n    skip: Symbol(\"deepmerge-ts: skip\"),\n};\n/**\n * Special values that tell deepmergeInto to perform a certain action.\n */\nconst actionsInto = {\n    defaultMerge: actions.defaultMerge,\n};\n\n/**\n * The default function to update meta data.\n *\n * It doesn't update the meta data.\n */\nfunction defaultMetaDataUpdater(previousMeta, metaMeta) {\n    return metaMeta;\n}\n/**\n * The default function to filter values.\n *\n * It filters out undefined values.\n */\nfunction defaultFilterValues(values, meta) {\n    return values.filter((value) => value !== undefined);\n}\n\n/**\n * The different types of objects deepmerge-ts support.\n */\nvar ObjectType;\n(function (ObjectType) {\n    ObjectType[ObjectType[\"NOT\"] = 0] = \"NOT\";\n    ObjectType[ObjectType[\"RECORD\"] = 1] = \"RECORD\";\n    ObjectType[ObjectType[\"ARRAY\"] = 2] = \"ARRAY\";\n    ObjectType[ObjectType[\"SET\"] = 3] = \"SET\";\n    ObjectType[ObjectType[\"MAP\"] = 4] = \"MAP\";\n    ObjectType[ObjectType[\"OTHER\"] = 5] = \"OTHER\";\n})(ObjectType || (ObjectType = {}));\n/**\n * Get the type of the given object.\n *\n * @param object - The object to get the type of.\n * @returns The type of the given object.\n */\nfunction getObjectType(object) {\n    if (typeof object !== \"object\" || object === null) {\n        return 0 /* ObjectType.NOT */;\n    }\n    if (Array.isArray(object)) {\n        return 2 /* ObjectType.ARRAY */;\n    }\n    if (isRecord(object)) {\n        return 1 /* ObjectType.RECORD */;\n    }\n    if (object instanceof Set) {\n        return 3 /* ObjectType.SET */;\n    }\n    if (object instanceof Map) {\n        return 4 /* ObjectType.MAP */;\n    }\n    return 5 /* ObjectType.OTHER */;\n}\n/**\n * Get the keys of the given objects including symbol keys.\n *\n * Note: Only keys to enumerable properties are returned.\n *\n * @param objects - An array of objects to get the keys of.\n * @returns A set containing all the keys of all the given objects.\n */\nfunction getKeys(objects) {\n    const keys = new Set();\n    for (const object of objects) {\n        for (const key of [...Object.keys(object), ...Object.getOwnPropertySymbols(object)]) {\n            keys.add(key);\n        }\n    }\n    return keys;\n}\n/**\n * Does the given object have the given property.\n *\n * @param object - The object to test.\n * @param property - The property to test.\n * @returns Whether the object has the property.\n */\nfunction objectHasProperty(object, property) {\n    return typeof object === \"object\" && Object.prototype.propertyIsEnumerable.call(object, property);\n}\n/**\n * Get an iterable object that iterates over the given iterables.\n */\nfunction getIterableOfIterables(iterables) {\n    let m_iterablesIndex = 0;\n    let m_iterator = iterables[0]?.[Symbol.iterator]();\n    return {\n        [Symbol.iterator]() {\n            return {\n                next() {\n                    do {\n                        if (m_iterator === undefined) {\n                            return { done: true, value: undefined };\n                        }\n                        const result = m_iterator.next();\n                        if (result.done === true) {\n                            m_iterablesIndex += 1;\n                            m_iterator = iterables[m_iterablesIndex]?.[Symbol.iterator]();\n                            continue;\n                        }\n                        return {\n                            done: false,\n                            value: result.value,\n                        };\n                    } while (true);\n                },\n            };\n        },\n    };\n}\n// eslint-disable-next-line unicorn/prefer-set-has -- Array is more performant for a low number of elements.\nconst validRecordToStringValues = [\"[object Object]\", \"[object Module]\"];\n/**\n * Does the given object appear to be a record.\n */\nfunction isRecord(value) {\n    // All records are objects.\n    if (!validRecordToStringValues.includes(Object.prototype.toString.call(value))) {\n        return false;\n    }\n    const { constructor } = value;\n    // If has modified constructor.\n    // eslint-disable-next-line ts/no-unnecessary-condition\n    if (constructor === undefined) {\n        return true;\n    }\n    const prototype = constructor.prototype;\n    // If has modified prototype.\n    if (prototype === null ||\n        typeof prototype !== \"object\" ||\n        !validRecordToStringValues.includes(Object.prototype.toString.call(prototype))) {\n        return false;\n    }\n    // If constructor does not have an Object-specific method.\n    // eslint-disable-next-line sonar/prefer-single-boolean-return, no-prototype-builtins\n    if (!prototype.hasOwnProperty(\"isPrototypeOf\")) {\n        return false;\n    }\n    // Most likely a record.\n    return true;\n}\n\n/**\n * The default strategy to merge records.\n *\n * @param values - The records.\n */\nfunction mergeRecords$1(values, utils, meta) {\n    const result = {};\n    for (const key of getKeys(values)) {\n        const propValues = [];\n        for (const value of values) {\n            if (objectHasProperty(value, key)) {\n                propValues.push(value[key]);\n            }\n        }\n        if (propValues.length === 0) {\n            continue;\n        }\n        const updatedMeta = utils.metaDataUpdater(meta, {\n            key,\n            parents: values,\n        });\n        const propertyResult = mergeUnknowns(propValues, utils, updatedMeta);\n        if (propertyResult === actions.skip) {\n            continue;\n        }\n        if (key === \"__proto__\") {\n            Object.defineProperty(result, key, {\n                value: propertyResult,\n                configurable: true,\n                enumerable: true,\n                writable: true,\n            });\n        }\n        else {\n            result[key] = propertyResult;\n        }\n    }\n    return result;\n}\n/**\n * The default strategy to merge arrays.\n *\n * @param values - The arrays.\n */\nfunction mergeArrays$1(values) {\n    return values.flat();\n}\n/**\n * The default strategy to merge sets.\n *\n * @param values - The sets.\n */\nfunction mergeSets$1(values) {\n    return new Set(getIterableOfIterables(values));\n}\n/**\n * The default strategy to merge maps.\n *\n * @param values - The maps.\n */\nfunction mergeMaps$1(values) {\n    return new Map(getIterableOfIterables(values));\n}\n/**\n * Get the last non-undefined value in the given array.\n */\nfunction mergeOthers$1(values) {\n    return values.at(-1);\n}\n/**\n * The merge functions.\n */\nconst mergeFunctions = {\n    mergeRecords: mergeRecords$1,\n    mergeArrays: mergeArrays$1,\n    mergeSets: mergeSets$1,\n    mergeMaps: mergeMaps$1,\n    mergeOthers: mergeOthers$1,\n};\n\n/**\n * Deeply merge objects.\n *\n * @param objects - The objects to merge.\n */\nfunction deepmerge(...objects) {\n    return deepmergeCustom({})(...objects);\n}\nfunction deepmergeCustom(options, rootMetaData) {\n    const utils = getUtils(options, customizedDeepmerge);\n    /**\n     * The customized deepmerge function.\n     */\n    function customizedDeepmerge(...objects) {\n        return mergeUnknowns(objects, utils, rootMetaData);\n    }\n    return customizedDeepmerge;\n}\n/**\n * The the utils that are available to the merge functions.\n *\n * @param options - The options the user specified\n */\nfunction getUtils(options, customizedDeepmerge) {\n    return {\n        defaultMergeFunctions: mergeFunctions,\n        mergeFunctions: {\n            ...mergeFunctions,\n            ...Object.fromEntries(Object.entries(options)\n                .filter(([key, option]) => Object.hasOwn(mergeFunctions, key))\n                .map(([key, option]) => (option === false ? [key, mergeFunctions.mergeOthers] : [key, option]))),\n        },\n        metaDataUpdater: (options.metaDataUpdater ?? defaultMetaDataUpdater),\n        deepmerge: customizedDeepmerge,\n        useImplicitDefaultMerging: options.enableImplicitDefaultMerging ?? false,\n        filterValues: options.filterValues === false ? undefined : (options.filterValues ?? defaultFilterValues),\n        actions,\n    };\n}\n/**\n * Merge unknown things.\n *\n * @param values - The values.\n */\nfunction mergeUnknowns(values, utils, meta) {\n    const filteredValues = utils.filterValues?.(values, meta) ?? values;\n    if (filteredValues.length === 0) {\n        return undefined;\n    }\n    if (filteredValues.length === 1) {\n        return mergeOthers(filteredValues, utils, meta);\n    }\n    const type = getObjectType(filteredValues[0]);\n    if (type !== 0 /* ObjectType.NOT */ && type !== 5 /* ObjectType.OTHER */) {\n        for (let m_index = 1; m_index < filteredValues.length; m_index++) {\n            if (getObjectType(filteredValues[m_index]) === type) {\n                continue;\n            }\n            return mergeOthers(filteredValues, utils, meta);\n        }\n    }\n    switch (type) {\n        case 1 /* ObjectType.RECORD */: {\n            return mergeRecords(filteredValues, utils, meta);\n        }\n        case 2 /* ObjectType.ARRAY */: {\n            return mergeArrays(filteredValues, utils, meta);\n        }\n        case 3 /* ObjectType.SET */: {\n            return mergeSets(filteredValues, utils, meta);\n        }\n        case 4 /* ObjectType.MAP */: {\n            return mergeMaps(filteredValues, utils, meta);\n        }\n        default: {\n            return mergeOthers(filteredValues, utils, meta);\n        }\n    }\n}\n/**\n * Merge records.\n *\n * @param values - The records.\n */\nfunction mergeRecords(values, utils, meta) {\n    const result = utils.mergeFunctions.mergeRecords(values, utils, meta);\n    if (result === actions.defaultMerge ||\n        (utils.useImplicitDefaultMerging &&\n            result === undefined &&\n            utils.mergeFunctions.mergeRecords !== utils.defaultMergeFunctions.mergeRecords)) {\n        return utils.defaultMergeFunctions.mergeRecords(values, utils, meta);\n    }\n    return result;\n}\n/**\n * Merge arrays.\n *\n * @param values - The arrays.\n */\nfunction mergeArrays(values, utils, meta) {\n    const result = utils.mergeFunctions.mergeArrays(values, utils, meta);\n    if (result === actions.defaultMerge ||\n        (utils.useImplicitDefaultMerging &&\n            result === undefined &&\n            utils.mergeFunctions.mergeArrays !== utils.defaultMergeFunctions.mergeArrays)) {\n        return utils.defaultMergeFunctions.mergeArrays(values);\n    }\n    return result;\n}\n/**\n * Merge sets.\n *\n * @param values - The sets.\n */\nfunction mergeSets(values, utils, meta) {\n    const result = utils.mergeFunctions.mergeSets(values, utils, meta);\n    if (result === actions.defaultMerge ||\n        (utils.useImplicitDefaultMerging &&\n            result === undefined &&\n            utils.mergeFunctions.mergeSets !== utils.defaultMergeFunctions.mergeSets)) {\n        return utils.defaultMergeFunctions.mergeSets(values);\n    }\n    return result;\n}\n/**\n * Merge maps.\n *\n * @param values - The maps.\n */\nfunction mergeMaps(values, utils, meta) {\n    const result = utils.mergeFunctions.mergeMaps(values, utils, meta);\n    if (result === actions.defaultMerge ||\n        (utils.useImplicitDefaultMerging &&\n            result === undefined &&\n            utils.mergeFunctions.mergeMaps !== utils.defaultMergeFunctions.mergeMaps)) {\n        return utils.defaultMergeFunctions.mergeMaps(values);\n    }\n    return result;\n}\n/**\n * Merge other things.\n *\n * @param values - The other things.\n */\nfunction mergeOthers(values, utils, meta) {\n    const result = utils.mergeFunctions.mergeOthers(values, utils, meta);\n    if (result === actions.defaultMerge ||\n        (utils.useImplicitDefaultMerging &&\n            result === undefined &&\n            utils.mergeFunctions.mergeOthers !== utils.defaultMergeFunctions.mergeOthers)) {\n        return utils.defaultMergeFunctions.mergeOthers(values);\n    }\n    return result;\n}\n\n/**\n * The default strategy to merge records into a target record.\n *\n * @param m_target - The result will be mutated into this record\n * @param values - The records (including the target's value if there is one).\n */\nfunction mergeRecordsInto$1(m_target, values, utils, meta) {\n    for (const key of getKeys(values)) {\n        const propValues = [];\n        for (const value of values) {\n            if (objectHasProperty(value, key)) {\n                propValues.push(value[key]);\n            }\n        }\n        if (propValues.length === 0) {\n            continue;\n        }\n        const updatedMeta = utils.metaDataUpdater(meta, {\n            key,\n            parents: values,\n        });\n        const propertyTarget = { value: propValues[0] };\n        mergeUnknownsInto(propertyTarget, propValues, utils, updatedMeta);\n        if (key === \"__proto__\") {\n            Object.defineProperty(m_target.value, key, {\n                value: propertyTarget.value,\n                configurable: true,\n                enumerable: true,\n                writable: true,\n            });\n        }\n        else {\n            m_target.value[key] = propertyTarget.value;\n        }\n    }\n}\n/**\n * The default strategy to merge arrays into a target array.\n *\n * @param m_target - The result will be mutated into this array\n * @param values - The arrays (including the target's value if there is one).\n */\nfunction mergeArraysInto$1(m_target, values) {\n    m_target.value.push(...values.slice(1).flat());\n}\n/**\n * The default strategy to merge sets into a target set.\n *\n * @param m_target - The result will be mutated into this set\n * @param values - The sets (including the target's value if there is one).\n */\nfunction mergeSetsInto$1(m_target, values) {\n    for (const value of getIterableOfIterables(values.slice(1))) {\n        m_target.value.add(value);\n    }\n}\n/**\n * The default strategy to merge maps into a target map.\n *\n * @param m_target - The result will be mutated into this map\n * @param values - The maps (including the target's value if there is one).\n */\nfunction mergeMapsInto$1(m_target, values) {\n    for (const [key, value] of getIterableOfIterables(values.slice(1))) {\n        m_target.value.set(key, value);\n    }\n}\n/**\n * Set the target to the last non-undefined value.\n */\nfunction mergeOthersInto$1(m_target, values) {\n    m_target.value = values.at(-1);\n}\n/**\n * The merge functions.\n */\nconst mergeIntoFunctions = {\n    mergeRecords: mergeRecordsInto$1,\n    mergeArrays: mergeArraysInto$1,\n    mergeSets: mergeSetsInto$1,\n    mergeMaps: mergeMapsInto$1,\n    mergeOthers: mergeOthersInto$1,\n};\n\nfunction deepmergeInto(target, ...objects) {\n    return void deepmergeIntoCustom({})(target, ...objects);\n}\nfunction deepmergeIntoCustom(options, rootMetaData) {\n    const utils = getIntoUtils(options, customizedDeepmergeInto);\n    /**\n     * The customized deepmerge function.\n     */\n    function customizedDeepmergeInto(target, ...objects) {\n        mergeUnknownsInto({ value: target }, [target, ...objects], utils, rootMetaData);\n    }\n    return customizedDeepmergeInto;\n}\n/**\n * The the utils that are available to the merge functions.\n *\n * @param options - The options the user specified\n */\nfunction getIntoUtils(options, customizedDeepmergeInto) {\n    return {\n        defaultMergeFunctions: mergeIntoFunctions,\n        mergeFunctions: {\n            ...mergeIntoFunctions,\n            ...Object.fromEntries(Object.entries(options)\n                .filter(([key, option]) => Object.hasOwn(mergeIntoFunctions, key))\n                .map(([key, option]) => (option === false ? [key, mergeIntoFunctions.mergeOthers] : [key, option]))),\n        },\n        metaDataUpdater: (options.metaDataUpdater ?? defaultMetaDataUpdater),\n        deepmergeInto: customizedDeepmergeInto,\n        filterValues: options.filterValues === false ? undefined : (options.filterValues ?? defaultFilterValues),\n        actions: actionsInto,\n    };\n}\n/**\n * Merge unknown things into a target.\n *\n * @param m_target - The target to merge into.\n * @param values - The values.\n */\nfunction mergeUnknownsInto(m_target, values, utils, meta) {\n    const filteredValues = utils.filterValues?.(values, meta) ?? values;\n    if (filteredValues.length === 0) {\n        return;\n    }\n    if (filteredValues.length === 1) {\n        return void mergeOthersInto(m_target, filteredValues, utils, meta);\n    }\n    const type = getObjectType(m_target.value);\n    if (type !== 0 /* ObjectType.NOT */ && type !== 5 /* ObjectType.OTHER */) {\n        for (let m_index = 1; m_index < filteredValues.length; m_index++) {\n            if (getObjectType(filteredValues[m_index]) === type) {\n                continue;\n            }\n            return void mergeOthersInto(m_target, filteredValues, utils, meta);\n        }\n    }\n    switch (type) {\n        case 1 /* ObjectType.RECORD */: {\n            return void mergeRecordsInto(m_target, filteredValues, utils, meta);\n        }\n        case 2 /* ObjectType.ARRAY */: {\n            return void mergeArraysInto(m_target, filteredValues, utils, meta);\n        }\n        case 3 /* ObjectType.SET */: {\n            return void mergeSetsInto(m_target, filteredValues, utils, meta);\n        }\n        case 4 /* ObjectType.MAP */: {\n            return void mergeMapsInto(m_target, filteredValues, utils, meta);\n        }\n        default: {\n            return void mergeOthersInto(m_target, filteredValues, utils, meta);\n        }\n    }\n}\n/**\n * Merge records into a target record.\n *\n * @param m_target - The target to merge into.\n * @param values - The records.\n */\nfunction mergeRecordsInto(m_target, values, utils, meta) {\n    const action = utils.mergeFunctions.mergeRecords(m_target, values, utils, meta);\n    if (action === actionsInto.defaultMerge) {\n        utils.defaultMergeFunctions.mergeRecords(m_target, values, utils, meta);\n    }\n}\n/**\n * Merge arrays into a target array.\n *\n * @param m_target - The target to merge into.\n * @param values - The arrays.\n */\nfunction mergeArraysInto(m_target, values, utils, meta) {\n    const action = utils.mergeFunctions.mergeArrays(m_target, values, utils, meta);\n    if (action === actionsInto.defaultMerge) {\n        utils.defaultMergeFunctions.mergeArrays(m_target, values);\n    }\n}\n/**\n * Merge sets into a target set.\n *\n * @param m_target - The target to merge into.\n * @param values - The sets.\n */\nfunction mergeSetsInto(m_target, values, utils, meta) {\n    const action = utils.mergeFunctions.mergeSets(m_target, values, utils, meta);\n    if (action === actionsInto.defaultMerge) {\n        utils.defaultMergeFunctions.mergeSets(m_target, values);\n    }\n}\n/**\n * Merge maps into a target map.\n *\n * @param m_target - The target to merge into.\n * @param values - The maps.\n */\nfunction mergeMapsInto(m_target, values, utils, meta) {\n    const action = utils.mergeFunctions.mergeMaps(m_target, values, utils, meta);\n    if (action === actionsInto.defaultMerge) {\n        utils.defaultMergeFunctions.mergeMaps(m_target, values);\n    }\n}\n/**\n * Merge other things into a target.\n *\n * @param m_target - The target to merge into.\n * @param values - The other things.\n */\nfunction mergeOthersInto(m_target, values, utils, meta) {\n    const action = utils.mergeFunctions.mergeOthers(m_target, values, utils, meta);\n    if (action === actionsInto.defaultMerge || m_target.value === actionsInto.defaultMerge) {\n        utils.defaultMergeFunctions.mergeOthers(m_target, values);\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vbm9kZV9tb2R1bGVzL2RlZXBtZXJnZS10cy9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpQ0FBaUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpQ0FBaUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVxSCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxhYnJtbVxcTm9kaWZ5XFxQcm9qZWN0c1xcYm9va2luZ192MlxcbmV4dC1hcHBcXG5vZGVfbW9kdWxlc1xcZGVlcG1lcmdlLXRzXFxkaXN0XFxpbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTcGVjaWFsIHZhbHVlcyB0aGF0IHRlbGwgZGVlcG1lcmdlIHRvIHBlcmZvcm0gYSBjZXJ0YWluIGFjdGlvbi5cbiAqL1xuY29uc3QgYWN0aW9ucyA9IHtcbiAgICBkZWZhdWx0TWVyZ2U6IFN5bWJvbChcImRlZXBtZXJnZS10czogZGVmYXVsdCBtZXJnZVwiKSxcbiAgICBza2lwOiBTeW1ib2woXCJkZWVwbWVyZ2UtdHM6IHNraXBcIiksXG59O1xuLyoqXG4gKiBTcGVjaWFsIHZhbHVlcyB0aGF0IHRlbGwgZGVlcG1lcmdlSW50byB0byBwZXJmb3JtIGEgY2VydGFpbiBhY3Rpb24uXG4gKi9cbmNvbnN0IGFjdGlvbnNJbnRvID0ge1xuICAgIGRlZmF1bHRNZXJnZTogYWN0aW9ucy5kZWZhdWx0TWVyZ2UsXG59O1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGZ1bmN0aW9uIHRvIHVwZGF0ZSBtZXRhIGRhdGEuXG4gKlxuICogSXQgZG9lc24ndCB1cGRhdGUgdGhlIG1ldGEgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZGVmYXVsdE1ldGFEYXRhVXBkYXRlcihwcmV2aW91c01ldGEsIG1ldGFNZXRhKSB7XG4gICAgcmV0dXJuIG1ldGFNZXRhO1xufVxuLyoqXG4gKiBUaGUgZGVmYXVsdCBmdW5jdGlvbiB0byBmaWx0ZXIgdmFsdWVzLlxuICpcbiAqIEl0IGZpbHRlcnMgb3V0IHVuZGVmaW5lZCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRGaWx0ZXJWYWx1ZXModmFsdWVzLCBtZXRhKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5maWx0ZXIoKHZhbHVlKSA9PiB2YWx1ZSAhPT0gdW5kZWZpbmVkKTtcbn1cblxuLyoqXG4gKiBUaGUgZGlmZmVyZW50IHR5cGVzIG9mIG9iamVjdHMgZGVlcG1lcmdlLXRzIHN1cHBvcnQuXG4gKi9cbnZhciBPYmplY3RUeXBlO1xuKGZ1bmN0aW9uIChPYmplY3RUeXBlKSB7XG4gICAgT2JqZWN0VHlwZVtPYmplY3RUeXBlW1wiTk9UXCJdID0gMF0gPSBcIk5PVFwiO1xuICAgIE9iamVjdFR5cGVbT2JqZWN0VHlwZVtcIlJFQ09SRFwiXSA9IDFdID0gXCJSRUNPUkRcIjtcbiAgICBPYmplY3RUeXBlW09iamVjdFR5cGVbXCJBUlJBWVwiXSA9IDJdID0gXCJBUlJBWVwiO1xuICAgIE9iamVjdFR5cGVbT2JqZWN0VHlwZVtcIlNFVFwiXSA9IDNdID0gXCJTRVRcIjtcbiAgICBPYmplY3RUeXBlW09iamVjdFR5cGVbXCJNQVBcIl0gPSA0XSA9IFwiTUFQXCI7XG4gICAgT2JqZWN0VHlwZVtPYmplY3RUeXBlW1wiT1RIRVJcIl0gPSA1XSA9IFwiT1RIRVJcIjtcbn0pKE9iamVjdFR5cGUgfHwgKE9iamVjdFR5cGUgPSB7fSkpO1xuLyoqXG4gKiBHZXQgdGhlIHR5cGUgb2YgdGhlIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byBnZXQgdGhlIHR5cGUgb2YuXG4gKiBAcmV0dXJucyBUaGUgdHlwZSBvZiB0aGUgZ2l2ZW4gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBnZXRPYmplY3RUeXBlKG9iamVjdCkge1xuICAgIGlmICh0eXBlb2Ygb2JqZWN0ICE9PSBcIm9iamVjdFwiIHx8IG9iamVjdCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gMCAvKiBPYmplY3RUeXBlLk5PVCAqLztcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gMiAvKiBPYmplY3RUeXBlLkFSUkFZICovO1xuICAgIH1cbiAgICBpZiAoaXNSZWNvcmQob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gMSAvKiBPYmplY3RUeXBlLlJFQ09SRCAqLztcbiAgICB9XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICByZXR1cm4gMyAvKiBPYmplY3RUeXBlLlNFVCAqLztcbiAgICB9XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICByZXR1cm4gNCAvKiBPYmplY3RUeXBlLk1BUCAqLztcbiAgICB9XG4gICAgcmV0dXJuIDUgLyogT2JqZWN0VHlwZS5PVEhFUiAqLztcbn1cbi8qKlxuICogR2V0IHRoZSBrZXlzIG9mIHRoZSBnaXZlbiBvYmplY3RzIGluY2x1ZGluZyBzeW1ib2wga2V5cy5cbiAqXG4gKiBOb3RlOiBPbmx5IGtleXMgdG8gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFyZSByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gb2JqZWN0cyAtIEFuIGFycmF5IG9mIG9iamVjdHMgdG8gZ2V0IHRoZSBrZXlzIG9mLlxuICogQHJldHVybnMgQSBzZXQgY29udGFpbmluZyBhbGwgdGhlIGtleXMgb2YgYWxsIHRoZSBnaXZlbiBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBnZXRLZXlzKG9iamVjdHMpIHtcbiAgICBjb25zdCBrZXlzID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIG9iamVjdHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgWy4uLk9iamVjdC5rZXlzKG9iamVjdCksIC4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KV0pIHtcbiAgICAgICAgICAgIGtleXMuYWRkKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG59XG4vKipcbiAqIERvZXMgdGhlIGdpdmVuIG9iamVjdCBoYXZlIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byB0ZXN0LlxuICogQHBhcmFtIHByb3BlcnR5IC0gVGhlIHByb3BlcnR5IHRvIHRlc3QuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0SGFzUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHByb3BlcnR5KTtcbn1cbi8qKlxuICogR2V0IGFuIGl0ZXJhYmxlIG9iamVjdCB0aGF0IGl0ZXJhdGVzIG92ZXIgdGhlIGdpdmVuIGl0ZXJhYmxlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0SXRlcmFibGVPZkl0ZXJhYmxlcyhpdGVyYWJsZXMpIHtcbiAgICBsZXQgbV9pdGVyYWJsZXNJbmRleCA9IDA7XG4gICAgbGV0IG1faXRlcmF0b3IgPSBpdGVyYWJsZXNbMF0/LltTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5leHQoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtX2l0ZXJhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBtX2l0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZG9uZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1faXRlcmFibGVzSW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtX2l0ZXJhdG9yID0gaXRlcmFibGVzW21faXRlcmFibGVzSW5kZXhdPy5bU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1zZXQtaGFzIC0tIEFycmF5IGlzIG1vcmUgcGVyZm9ybWFudCBmb3IgYSBsb3cgbnVtYmVyIG9mIGVsZW1lbnRzLlxuY29uc3QgdmFsaWRSZWNvcmRUb1N0cmluZ1ZhbHVlcyA9IFtcIltvYmplY3QgT2JqZWN0XVwiLCBcIltvYmplY3QgTW9kdWxlXVwiXTtcbi8qKlxuICogRG9lcyB0aGUgZ2l2ZW4gb2JqZWN0IGFwcGVhciB0byBiZSBhIHJlY29yZC5cbiAqL1xuZnVuY3Rpb24gaXNSZWNvcmQodmFsdWUpIHtcbiAgICAvLyBBbGwgcmVjb3JkcyBhcmUgb2JqZWN0cy5cbiAgICBpZiAoIXZhbGlkUmVjb3JkVG9TdHJpbmdWYWx1ZXMuaW5jbHVkZXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7IGNvbnN0cnVjdG9yIH0gPSB2YWx1ZTtcbiAgICAvLyBJZiBoYXMgbW9kaWZpZWQgY29uc3RydWN0b3IuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHRzL25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgIGlmIChjb25zdHJ1Y3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBwcm90b3R5cGUgPSBjb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgLy8gSWYgaGFzIG1vZGlmaWVkIHByb3RvdHlwZS5cbiAgICBpZiAocHJvdG90eXBlID09PSBudWxsIHx8XG4gICAgICAgIHR5cGVvZiBwcm90b3R5cGUgIT09IFwib2JqZWN0XCIgfHxcbiAgICAgICAgIXZhbGlkUmVjb3JkVG9TdHJpbmdWYWx1ZXMuaW5jbHVkZXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHByb3RvdHlwZSkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gSWYgY29uc3RydWN0b3IgZG9lcyBub3QgaGF2ZSBhbiBPYmplY3Qtc3BlY2lmaWMgbWV0aG9kLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBzb25hci9wcmVmZXItc2luZ2xlLWJvb2xlYW4tcmV0dXJuLCBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICBpZiAoIXByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShcImlzUHJvdG90eXBlT2ZcIikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBNb3N0IGxpa2VseSBhIHJlY29yZC5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBzdHJhdGVneSB0byBtZXJnZSByZWNvcmRzLlxuICpcbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgcmVjb3Jkcy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VSZWNvcmRzJDEodmFsdWVzLCB1dGlscywgbWV0YSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGdldEtleXModmFsdWVzKSkge1xuICAgICAgICBjb25zdCBwcm9wVmFsdWVzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0SGFzUHJvcGVydHkodmFsdWUsIGtleSkpIHtcbiAgICAgICAgICAgICAgICBwcm9wVmFsdWVzLnB1c2godmFsdWVba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGRhdGVkTWV0YSA9IHV0aWxzLm1ldGFEYXRhVXBkYXRlcihtZXRhLCB7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBwYXJlbnRzOiB2YWx1ZXMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwcm9wZXJ0eVJlc3VsdCA9IG1lcmdlVW5rbm93bnMocHJvcFZhbHVlcywgdXRpbHMsIHVwZGF0ZWRNZXRhKTtcbiAgICAgICAgaWYgKHByb3BlcnR5UmVzdWx0ID09PSBhY3Rpb25zLnNraXApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgPT09IFwiX19wcm90b19fXCIpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsIGtleSwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBwcm9wZXJ0eVJlc3VsdCxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBwcm9wZXJ0eVJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBUaGUgZGVmYXVsdCBzdHJhdGVneSB0byBtZXJnZSBhcnJheXMuXG4gKlxuICogQHBhcmFtIHZhbHVlcyAtIFRoZSBhcnJheXMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQXJyYXlzJDEodmFsdWVzKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5mbGF0KCk7XG59XG4vKipcbiAqIFRoZSBkZWZhdWx0IHN0cmF0ZWd5IHRvIG1lcmdlIHNldHMuXG4gKlxuICogQHBhcmFtIHZhbHVlcyAtIFRoZSBzZXRzLlxuICovXG5mdW5jdGlvbiBtZXJnZVNldHMkMSh2YWx1ZXMpIHtcbiAgICByZXR1cm4gbmV3IFNldChnZXRJdGVyYWJsZU9mSXRlcmFibGVzKHZhbHVlcykpO1xufVxuLyoqXG4gKiBUaGUgZGVmYXVsdCBzdHJhdGVneSB0byBtZXJnZSBtYXBzLlxuICpcbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgbWFwcy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VNYXBzJDEodmFsdWVzKSB7XG4gICAgcmV0dXJuIG5ldyBNYXAoZ2V0SXRlcmFibGVPZkl0ZXJhYmxlcyh2YWx1ZXMpKTtcbn1cbi8qKlxuICogR2V0IHRoZSBsYXN0IG5vbi11bmRlZmluZWQgdmFsdWUgaW4gdGhlIGdpdmVuIGFycmF5LlxuICovXG5mdW5jdGlvbiBtZXJnZU90aGVycyQxKHZhbHVlcykge1xuICAgIHJldHVybiB2YWx1ZXMuYXQoLTEpO1xufVxuLyoqXG4gKiBUaGUgbWVyZ2UgZnVuY3Rpb25zLlxuICovXG5jb25zdCBtZXJnZUZ1bmN0aW9ucyA9IHtcbiAgICBtZXJnZVJlY29yZHM6IG1lcmdlUmVjb3JkcyQxLFxuICAgIG1lcmdlQXJyYXlzOiBtZXJnZUFycmF5cyQxLFxuICAgIG1lcmdlU2V0czogbWVyZ2VTZXRzJDEsXG4gICAgbWVyZ2VNYXBzOiBtZXJnZU1hcHMkMSxcbiAgICBtZXJnZU90aGVyczogbWVyZ2VPdGhlcnMkMSxcbn07XG5cbi8qKlxuICogRGVlcGx5IG1lcmdlIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIG9iamVjdHMgLSBUaGUgb2JqZWN0cyB0byBtZXJnZS5cbiAqL1xuZnVuY3Rpb24gZGVlcG1lcmdlKC4uLm9iamVjdHMpIHtcbiAgICByZXR1cm4gZGVlcG1lcmdlQ3VzdG9tKHt9KSguLi5vYmplY3RzKTtcbn1cbmZ1bmN0aW9uIGRlZXBtZXJnZUN1c3RvbShvcHRpb25zLCByb290TWV0YURhdGEpIHtcbiAgICBjb25zdCB1dGlscyA9IGdldFV0aWxzKG9wdGlvbnMsIGN1c3RvbWl6ZWREZWVwbWVyZ2UpO1xuICAgIC8qKlxuICAgICAqIFRoZSBjdXN0b21pemVkIGRlZXBtZXJnZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXN0b21pemVkRGVlcG1lcmdlKC4uLm9iamVjdHMpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlVW5rbm93bnMob2JqZWN0cywgdXRpbHMsIHJvb3RNZXRhRGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBjdXN0b21pemVkRGVlcG1lcmdlO1xufVxuLyoqXG4gKiBUaGUgdGhlIHV0aWxzIHRoYXQgYXJlIGF2YWlsYWJsZSB0byB0aGUgbWVyZ2UgZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdGhlIHVzZXIgc3BlY2lmaWVkXG4gKi9cbmZ1bmN0aW9uIGdldFV0aWxzKG9wdGlvbnMsIGN1c3RvbWl6ZWREZWVwbWVyZ2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWZhdWx0TWVyZ2VGdW5jdGlvbnM6IG1lcmdlRnVuY3Rpb25zLFxuICAgICAgICBtZXJnZUZ1bmN0aW9uczoge1xuICAgICAgICAgICAgLi4ubWVyZ2VGdW5jdGlvbnMsXG4gICAgICAgICAgICAuLi5PYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMob3B0aW9ucylcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChba2V5LCBvcHRpb25dKSA9PiBPYmplY3QuaGFzT3duKG1lcmdlRnVuY3Rpb25zLCBrZXkpKVxuICAgICAgICAgICAgICAgIC5tYXAoKFtrZXksIG9wdGlvbl0pID0+IChvcHRpb24gPT09IGZhbHNlID8gW2tleSwgbWVyZ2VGdW5jdGlvbnMubWVyZ2VPdGhlcnNdIDogW2tleSwgb3B0aW9uXSkpKSxcbiAgICAgICAgfSxcbiAgICAgICAgbWV0YURhdGFVcGRhdGVyOiAob3B0aW9ucy5tZXRhRGF0YVVwZGF0ZXIgPz8gZGVmYXVsdE1ldGFEYXRhVXBkYXRlciksXG4gICAgICAgIGRlZXBtZXJnZTogY3VzdG9taXplZERlZXBtZXJnZSxcbiAgICAgICAgdXNlSW1wbGljaXREZWZhdWx0TWVyZ2luZzogb3B0aW9ucy5lbmFibGVJbXBsaWNpdERlZmF1bHRNZXJnaW5nID8/IGZhbHNlLFxuICAgICAgICBmaWx0ZXJWYWx1ZXM6IG9wdGlvbnMuZmlsdGVyVmFsdWVzID09PSBmYWxzZSA/IHVuZGVmaW5lZCA6IChvcHRpb25zLmZpbHRlclZhbHVlcyA/PyBkZWZhdWx0RmlsdGVyVmFsdWVzKSxcbiAgICAgICAgYWN0aW9ucyxcbiAgICB9O1xufVxuLyoqXG4gKiBNZXJnZSB1bmtub3duIHRoaW5ncy5cbiAqXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VVbmtub3ducyh2YWx1ZXMsIHV0aWxzLCBtZXRhKSB7XG4gICAgY29uc3QgZmlsdGVyZWRWYWx1ZXMgPSB1dGlscy5maWx0ZXJWYWx1ZXM/Lih2YWx1ZXMsIG1ldGEpID8/IHZhbHVlcztcbiAgICBpZiAoZmlsdGVyZWRWYWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChmaWx0ZXJlZFZhbHVlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlT3RoZXJzKGZpbHRlcmVkVmFsdWVzLCB1dGlscywgbWV0YSk7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSBnZXRPYmplY3RUeXBlKGZpbHRlcmVkVmFsdWVzWzBdKTtcbiAgICBpZiAodHlwZSAhPT0gMCAvKiBPYmplY3RUeXBlLk5PVCAqLyAmJiB0eXBlICE9PSA1IC8qIE9iamVjdFR5cGUuT1RIRVIgKi8pIHtcbiAgICAgICAgZm9yIChsZXQgbV9pbmRleCA9IDE7IG1faW5kZXggPCBmaWx0ZXJlZFZhbHVlcy5sZW5ndGg7IG1faW5kZXgrKykge1xuICAgICAgICAgICAgaWYgKGdldE9iamVjdFR5cGUoZmlsdGVyZWRWYWx1ZXNbbV9pbmRleF0pID09PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VPdGhlcnMoZmlsdGVyZWRWYWx1ZXMsIHV0aWxzLCBtZXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAxIC8qIE9iamVjdFR5cGUuUkVDT1JEICovOiB7XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VSZWNvcmRzKGZpbHRlcmVkVmFsdWVzLCB1dGlscywgbWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAyIC8qIE9iamVjdFR5cGUuQVJSQVkgKi86IHtcbiAgICAgICAgICAgIHJldHVybiBtZXJnZUFycmF5cyhmaWx0ZXJlZFZhbHVlcywgdXRpbHMsIG1ldGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMyAvKiBPYmplY3RUeXBlLlNFVCAqLzoge1xuICAgICAgICAgICAgcmV0dXJuIG1lcmdlU2V0cyhmaWx0ZXJlZFZhbHVlcywgdXRpbHMsIG1ldGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgNCAvKiBPYmplY3RUeXBlLk1BUCAqLzoge1xuICAgICAgICAgICAgcmV0dXJuIG1lcmdlTWFwcyhmaWx0ZXJlZFZhbHVlcywgdXRpbHMsIG1ldGEpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIHJldHVybiBtZXJnZU90aGVycyhmaWx0ZXJlZFZhbHVlcywgdXRpbHMsIG1ldGEpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBNZXJnZSByZWNvcmRzLlxuICpcbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgcmVjb3Jkcy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VSZWNvcmRzKHZhbHVlcywgdXRpbHMsIG1ldGEpIHtcbiAgICBjb25zdCByZXN1bHQgPSB1dGlscy5tZXJnZUZ1bmN0aW9ucy5tZXJnZVJlY29yZHModmFsdWVzLCB1dGlscywgbWV0YSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gYWN0aW9ucy5kZWZhdWx0TWVyZ2UgfHxcbiAgICAgICAgKHV0aWxzLnVzZUltcGxpY2l0RGVmYXVsdE1lcmdpbmcgJiZcbiAgICAgICAgICAgIHJlc3VsdCA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB1dGlscy5tZXJnZUZ1bmN0aW9ucy5tZXJnZVJlY29yZHMgIT09IHV0aWxzLmRlZmF1bHRNZXJnZUZ1bmN0aW9ucy5tZXJnZVJlY29yZHMpKSB7XG4gICAgICAgIHJldHVybiB1dGlscy5kZWZhdWx0TWVyZ2VGdW5jdGlvbnMubWVyZ2VSZWNvcmRzKHZhbHVlcywgdXRpbHMsIG1ldGEpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBNZXJnZSBhcnJheXMuXG4gKlxuICogQHBhcmFtIHZhbHVlcyAtIFRoZSBhcnJheXMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQXJyYXlzKHZhbHVlcywgdXRpbHMsIG1ldGEpIHtcbiAgICBjb25zdCByZXN1bHQgPSB1dGlscy5tZXJnZUZ1bmN0aW9ucy5tZXJnZUFycmF5cyh2YWx1ZXMsIHV0aWxzLCBtZXRhKTtcbiAgICBpZiAocmVzdWx0ID09PSBhY3Rpb25zLmRlZmF1bHRNZXJnZSB8fFxuICAgICAgICAodXRpbHMudXNlSW1wbGljaXREZWZhdWx0TWVyZ2luZyAmJlxuICAgICAgICAgICAgcmVzdWx0ID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHV0aWxzLm1lcmdlRnVuY3Rpb25zLm1lcmdlQXJyYXlzICE9PSB1dGlscy5kZWZhdWx0TWVyZ2VGdW5jdGlvbnMubWVyZ2VBcnJheXMpKSB7XG4gICAgICAgIHJldHVybiB1dGlscy5kZWZhdWx0TWVyZ2VGdW5jdGlvbnMubWVyZ2VBcnJheXModmFsdWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogTWVyZ2Ugc2V0cy5cbiAqXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHNldHMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlU2V0cyh2YWx1ZXMsIHV0aWxzLCBtZXRhKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdXRpbHMubWVyZ2VGdW5jdGlvbnMubWVyZ2VTZXRzKHZhbHVlcywgdXRpbHMsIG1ldGEpO1xuICAgIGlmIChyZXN1bHQgPT09IGFjdGlvbnMuZGVmYXVsdE1lcmdlIHx8XG4gICAgICAgICh1dGlscy51c2VJbXBsaWNpdERlZmF1bHRNZXJnaW5nICYmXG4gICAgICAgICAgICByZXN1bHQgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdXRpbHMubWVyZ2VGdW5jdGlvbnMubWVyZ2VTZXRzICE9PSB1dGlscy5kZWZhdWx0TWVyZ2VGdW5jdGlvbnMubWVyZ2VTZXRzKSkge1xuICAgICAgICByZXR1cm4gdXRpbHMuZGVmYXVsdE1lcmdlRnVuY3Rpb25zLm1lcmdlU2V0cyh2YWx1ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBNZXJnZSBtYXBzLlxuICpcbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgbWFwcy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VNYXBzKHZhbHVlcywgdXRpbHMsIG1ldGEpIHtcbiAgICBjb25zdCByZXN1bHQgPSB1dGlscy5tZXJnZUZ1bmN0aW9ucy5tZXJnZU1hcHModmFsdWVzLCB1dGlscywgbWV0YSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gYWN0aW9ucy5kZWZhdWx0TWVyZ2UgfHxcbiAgICAgICAgKHV0aWxzLnVzZUltcGxpY2l0RGVmYXVsdE1lcmdpbmcgJiZcbiAgICAgICAgICAgIHJlc3VsdCA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB1dGlscy5tZXJnZUZ1bmN0aW9ucy5tZXJnZU1hcHMgIT09IHV0aWxzLmRlZmF1bHRNZXJnZUZ1bmN0aW9ucy5tZXJnZU1hcHMpKSB7XG4gICAgICAgIHJldHVybiB1dGlscy5kZWZhdWx0TWVyZ2VGdW5jdGlvbnMubWVyZ2VNYXBzKHZhbHVlcyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIE1lcmdlIG90aGVyIHRoaW5ncy5cbiAqXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIG90aGVyIHRoaW5ncy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VPdGhlcnModmFsdWVzLCB1dGlscywgbWV0YSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHV0aWxzLm1lcmdlRnVuY3Rpb25zLm1lcmdlT3RoZXJzKHZhbHVlcywgdXRpbHMsIG1ldGEpO1xuICAgIGlmIChyZXN1bHQgPT09IGFjdGlvbnMuZGVmYXVsdE1lcmdlIHx8XG4gICAgICAgICh1dGlscy51c2VJbXBsaWNpdERlZmF1bHRNZXJnaW5nICYmXG4gICAgICAgICAgICByZXN1bHQgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdXRpbHMubWVyZ2VGdW5jdGlvbnMubWVyZ2VPdGhlcnMgIT09IHV0aWxzLmRlZmF1bHRNZXJnZUZ1bmN0aW9ucy5tZXJnZU90aGVycykpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzLmRlZmF1bHRNZXJnZUZ1bmN0aW9ucy5tZXJnZU90aGVycyh2YWx1ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IHN0cmF0ZWd5IHRvIG1lcmdlIHJlY29yZHMgaW50byBhIHRhcmdldCByZWNvcmQuXG4gKlxuICogQHBhcmFtIG1fdGFyZ2V0IC0gVGhlIHJlc3VsdCB3aWxsIGJlIG11dGF0ZWQgaW50byB0aGlzIHJlY29yZFxuICogQHBhcmFtIHZhbHVlcyAtIFRoZSByZWNvcmRzIChpbmNsdWRpbmcgdGhlIHRhcmdldCdzIHZhbHVlIGlmIHRoZXJlIGlzIG9uZSkuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlUmVjb3Jkc0ludG8kMShtX3RhcmdldCwgdmFsdWVzLCB1dGlscywgbWV0YSkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGdldEtleXModmFsdWVzKSkge1xuICAgICAgICBjb25zdCBwcm9wVmFsdWVzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0SGFzUHJvcGVydHkodmFsdWUsIGtleSkpIHtcbiAgICAgICAgICAgICAgICBwcm9wVmFsdWVzLnB1c2godmFsdWVba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGRhdGVkTWV0YSA9IHV0aWxzLm1ldGFEYXRhVXBkYXRlcihtZXRhLCB7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBwYXJlbnRzOiB2YWx1ZXMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwcm9wZXJ0eVRhcmdldCA9IHsgdmFsdWU6IHByb3BWYWx1ZXNbMF0gfTtcbiAgICAgICAgbWVyZ2VVbmtub3duc0ludG8ocHJvcGVydHlUYXJnZXQsIHByb3BWYWx1ZXMsIHV0aWxzLCB1cGRhdGVkTWV0YSk7XG4gICAgICAgIGlmIChrZXkgPT09IFwiX19wcm90b19fXCIpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtX3RhcmdldC52YWx1ZSwga2V5LCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHByb3BlcnR5VGFyZ2V0LnZhbHVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtX3RhcmdldC52YWx1ZVtrZXldID0gcHJvcGVydHlUYXJnZXQudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFRoZSBkZWZhdWx0IHN0cmF0ZWd5IHRvIG1lcmdlIGFycmF5cyBpbnRvIGEgdGFyZ2V0IGFycmF5LlxuICpcbiAqIEBwYXJhbSBtX3RhcmdldCAtIFRoZSByZXN1bHQgd2lsbCBiZSBtdXRhdGVkIGludG8gdGhpcyBhcnJheVxuICogQHBhcmFtIHZhbHVlcyAtIFRoZSBhcnJheXMgKGluY2x1ZGluZyB0aGUgdGFyZ2V0J3MgdmFsdWUgaWYgdGhlcmUgaXMgb25lKS5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VBcnJheXNJbnRvJDEobV90YXJnZXQsIHZhbHVlcykge1xuICAgIG1fdGFyZ2V0LnZhbHVlLnB1c2goLi4udmFsdWVzLnNsaWNlKDEpLmZsYXQoKSk7XG59XG4vKipcbiAqIFRoZSBkZWZhdWx0IHN0cmF0ZWd5IHRvIG1lcmdlIHNldHMgaW50byBhIHRhcmdldCBzZXQuXG4gKlxuICogQHBhcmFtIG1fdGFyZ2V0IC0gVGhlIHJlc3VsdCB3aWxsIGJlIG11dGF0ZWQgaW50byB0aGlzIHNldFxuICogQHBhcmFtIHZhbHVlcyAtIFRoZSBzZXRzIChpbmNsdWRpbmcgdGhlIHRhcmdldCdzIHZhbHVlIGlmIHRoZXJlIGlzIG9uZSkuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlU2V0c0ludG8kMShtX3RhcmdldCwgdmFsdWVzKSB7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiBnZXRJdGVyYWJsZU9mSXRlcmFibGVzKHZhbHVlcy5zbGljZSgxKSkpIHtcbiAgICAgICAgbV90YXJnZXQudmFsdWUuYWRkKHZhbHVlKTtcbiAgICB9XG59XG4vKipcbiAqIFRoZSBkZWZhdWx0IHN0cmF0ZWd5IHRvIG1lcmdlIG1hcHMgaW50byBhIHRhcmdldCBtYXAuXG4gKlxuICogQHBhcmFtIG1fdGFyZ2V0IC0gVGhlIHJlc3VsdCB3aWxsIGJlIG11dGF0ZWQgaW50byB0aGlzIG1hcFxuICogQHBhcmFtIHZhbHVlcyAtIFRoZSBtYXBzIChpbmNsdWRpbmcgdGhlIHRhcmdldCdzIHZhbHVlIGlmIHRoZXJlIGlzIG9uZSkuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlTWFwc0ludG8kMShtX3RhcmdldCwgdmFsdWVzKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZ2V0SXRlcmFibGVPZkl0ZXJhYmxlcyh2YWx1ZXMuc2xpY2UoMSkpKSB7XG4gICAgICAgIG1fdGFyZ2V0LnZhbHVlLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG59XG4vKipcbiAqIFNldCB0aGUgdGFyZ2V0IHRvIHRoZSBsYXN0IG5vbi11bmRlZmluZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3RoZXJzSW50byQxKG1fdGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICBtX3RhcmdldC52YWx1ZSA9IHZhbHVlcy5hdCgtMSk7XG59XG4vKipcbiAqIFRoZSBtZXJnZSBmdW5jdGlvbnMuXG4gKi9cbmNvbnN0IG1lcmdlSW50b0Z1bmN0aW9ucyA9IHtcbiAgICBtZXJnZVJlY29yZHM6IG1lcmdlUmVjb3Jkc0ludG8kMSxcbiAgICBtZXJnZUFycmF5czogbWVyZ2VBcnJheXNJbnRvJDEsXG4gICAgbWVyZ2VTZXRzOiBtZXJnZVNldHNJbnRvJDEsXG4gICAgbWVyZ2VNYXBzOiBtZXJnZU1hcHNJbnRvJDEsXG4gICAgbWVyZ2VPdGhlcnM6IG1lcmdlT3RoZXJzSW50byQxLFxufTtcblxuZnVuY3Rpb24gZGVlcG1lcmdlSW50byh0YXJnZXQsIC4uLm9iamVjdHMpIHtcbiAgICByZXR1cm4gdm9pZCBkZWVwbWVyZ2VJbnRvQ3VzdG9tKHt9KSh0YXJnZXQsIC4uLm9iamVjdHMpO1xufVxuZnVuY3Rpb24gZGVlcG1lcmdlSW50b0N1c3RvbShvcHRpb25zLCByb290TWV0YURhdGEpIHtcbiAgICBjb25zdCB1dGlscyA9IGdldEludG9VdGlscyhvcHRpb25zLCBjdXN0b21pemVkRGVlcG1lcmdlSW50byk7XG4gICAgLyoqXG4gICAgICogVGhlIGN1c3RvbWl6ZWQgZGVlcG1lcmdlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1c3RvbWl6ZWREZWVwbWVyZ2VJbnRvKHRhcmdldCwgLi4ub2JqZWN0cykge1xuICAgICAgICBtZXJnZVVua25vd25zSW50byh7IHZhbHVlOiB0YXJnZXQgfSwgW3RhcmdldCwgLi4ub2JqZWN0c10sIHV0aWxzLCByb290TWV0YURhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gY3VzdG9taXplZERlZXBtZXJnZUludG87XG59XG4vKipcbiAqIFRoZSB0aGUgdXRpbHMgdGhhdCBhcmUgYXZhaWxhYmxlIHRvIHRoZSBtZXJnZSBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0aGUgdXNlciBzcGVjaWZpZWRcbiAqL1xuZnVuY3Rpb24gZ2V0SW50b1V0aWxzKG9wdGlvbnMsIGN1c3RvbWl6ZWREZWVwbWVyZ2VJbnRvKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVmYXVsdE1lcmdlRnVuY3Rpb25zOiBtZXJnZUludG9GdW5jdGlvbnMsXG4gICAgICAgIG1lcmdlRnVuY3Rpb25zOiB7XG4gICAgICAgICAgICAuLi5tZXJnZUludG9GdW5jdGlvbnMsXG4gICAgICAgICAgICAuLi5PYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMob3B0aW9ucylcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChba2V5LCBvcHRpb25dKSA9PiBPYmplY3QuaGFzT3duKG1lcmdlSW50b0Z1bmN0aW9ucywga2V5KSlcbiAgICAgICAgICAgICAgICAubWFwKChba2V5LCBvcHRpb25dKSA9PiAob3B0aW9uID09PSBmYWxzZSA/IFtrZXksIG1lcmdlSW50b0Z1bmN0aW9ucy5tZXJnZU90aGVyc10gOiBba2V5LCBvcHRpb25dKSkpLFxuICAgICAgICB9LFxuICAgICAgICBtZXRhRGF0YVVwZGF0ZXI6IChvcHRpb25zLm1ldGFEYXRhVXBkYXRlciA/PyBkZWZhdWx0TWV0YURhdGFVcGRhdGVyKSxcbiAgICAgICAgZGVlcG1lcmdlSW50bzogY3VzdG9taXplZERlZXBtZXJnZUludG8sXG4gICAgICAgIGZpbHRlclZhbHVlczogb3B0aW9ucy5maWx0ZXJWYWx1ZXMgPT09IGZhbHNlID8gdW5kZWZpbmVkIDogKG9wdGlvbnMuZmlsdGVyVmFsdWVzID8/IGRlZmF1bHRGaWx0ZXJWYWx1ZXMpLFxuICAgICAgICBhY3Rpb25zOiBhY3Rpb25zSW50byxcbiAgICB9O1xufVxuLyoqXG4gKiBNZXJnZSB1bmtub3duIHRoaW5ncyBpbnRvIGEgdGFyZ2V0LlxuICpcbiAqIEBwYXJhbSBtX3RhcmdldCAtIFRoZSB0YXJnZXQgdG8gbWVyZ2UgaW50by5cbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBtZXJnZVVua25vd25zSW50byhtX3RhcmdldCwgdmFsdWVzLCB1dGlscywgbWV0YSkge1xuICAgIGNvbnN0IGZpbHRlcmVkVmFsdWVzID0gdXRpbHMuZmlsdGVyVmFsdWVzPy4odmFsdWVzLCBtZXRhKSA/PyB2YWx1ZXM7XG4gICAgaWYgKGZpbHRlcmVkVmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChmaWx0ZXJlZFZhbHVlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgbWVyZ2VPdGhlcnNJbnRvKG1fdGFyZ2V0LCBmaWx0ZXJlZFZhbHVlcywgdXRpbHMsIG1ldGEpO1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gZ2V0T2JqZWN0VHlwZShtX3RhcmdldC52YWx1ZSk7XG4gICAgaWYgKHR5cGUgIT09IDAgLyogT2JqZWN0VHlwZS5OT1QgKi8gJiYgdHlwZSAhPT0gNSAvKiBPYmplY3RUeXBlLk9USEVSICovKSB7XG4gICAgICAgIGZvciAobGV0IG1faW5kZXggPSAxOyBtX2luZGV4IDwgZmlsdGVyZWRWYWx1ZXMubGVuZ3RoOyBtX2luZGV4KyspIHtcbiAgICAgICAgICAgIGlmIChnZXRPYmplY3RUeXBlKGZpbHRlcmVkVmFsdWVzW21faW5kZXhdKSA9PT0gdHlwZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZvaWQgbWVyZ2VPdGhlcnNJbnRvKG1fdGFyZ2V0LCBmaWx0ZXJlZFZhbHVlcywgdXRpbHMsIG1ldGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIDEgLyogT2JqZWN0VHlwZS5SRUNPUkQgKi86IHtcbiAgICAgICAgICAgIHJldHVybiB2b2lkIG1lcmdlUmVjb3Jkc0ludG8obV90YXJnZXQsIGZpbHRlcmVkVmFsdWVzLCB1dGlscywgbWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAyIC8qIE9iamVjdFR5cGUuQVJSQVkgKi86IHtcbiAgICAgICAgICAgIHJldHVybiB2b2lkIG1lcmdlQXJyYXlzSW50byhtX3RhcmdldCwgZmlsdGVyZWRWYWx1ZXMsIHV0aWxzLCBtZXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDMgLyogT2JqZWN0VHlwZS5TRVQgKi86IHtcbiAgICAgICAgICAgIHJldHVybiB2b2lkIG1lcmdlU2V0c0ludG8obV90YXJnZXQsIGZpbHRlcmVkVmFsdWVzLCB1dGlscywgbWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSA0IC8qIE9iamVjdFR5cGUuTUFQICovOiB7XG4gICAgICAgICAgICByZXR1cm4gdm9pZCBtZXJnZU1hcHNJbnRvKG1fdGFyZ2V0LCBmaWx0ZXJlZFZhbHVlcywgdXRpbHMsIG1ldGEpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIHJldHVybiB2b2lkIG1lcmdlT3RoZXJzSW50byhtX3RhcmdldCwgZmlsdGVyZWRWYWx1ZXMsIHV0aWxzLCBtZXRhKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogTWVyZ2UgcmVjb3JkcyBpbnRvIGEgdGFyZ2V0IHJlY29yZC5cbiAqXG4gKiBAcGFyYW0gbV90YXJnZXQgLSBUaGUgdGFyZ2V0IHRvIG1lcmdlIGludG8uXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHJlY29yZHMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlUmVjb3Jkc0ludG8obV90YXJnZXQsIHZhbHVlcywgdXRpbHMsIG1ldGEpIHtcbiAgICBjb25zdCBhY3Rpb24gPSB1dGlscy5tZXJnZUZ1bmN0aW9ucy5tZXJnZVJlY29yZHMobV90YXJnZXQsIHZhbHVlcywgdXRpbHMsIG1ldGEpO1xuICAgIGlmIChhY3Rpb24gPT09IGFjdGlvbnNJbnRvLmRlZmF1bHRNZXJnZSkge1xuICAgICAgICB1dGlscy5kZWZhdWx0TWVyZ2VGdW5jdGlvbnMubWVyZ2VSZWNvcmRzKG1fdGFyZ2V0LCB2YWx1ZXMsIHV0aWxzLCBtZXRhKTtcbiAgICB9XG59XG4vKipcbiAqIE1lcmdlIGFycmF5cyBpbnRvIGEgdGFyZ2V0IGFycmF5LlxuICpcbiAqIEBwYXJhbSBtX3RhcmdldCAtIFRoZSB0YXJnZXQgdG8gbWVyZ2UgaW50by5cbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgYXJyYXlzLlxuICovXG5mdW5jdGlvbiBtZXJnZUFycmF5c0ludG8obV90YXJnZXQsIHZhbHVlcywgdXRpbHMsIG1ldGEpIHtcbiAgICBjb25zdCBhY3Rpb24gPSB1dGlscy5tZXJnZUZ1bmN0aW9ucy5tZXJnZUFycmF5cyhtX3RhcmdldCwgdmFsdWVzLCB1dGlscywgbWV0YSk7XG4gICAgaWYgKGFjdGlvbiA9PT0gYWN0aW9uc0ludG8uZGVmYXVsdE1lcmdlKSB7XG4gICAgICAgIHV0aWxzLmRlZmF1bHRNZXJnZUZ1bmN0aW9ucy5tZXJnZUFycmF5cyhtX3RhcmdldCwgdmFsdWVzKTtcbiAgICB9XG59XG4vKipcbiAqIE1lcmdlIHNldHMgaW50byBhIHRhcmdldCBzZXQuXG4gKlxuICogQHBhcmFtIG1fdGFyZ2V0IC0gVGhlIHRhcmdldCB0byBtZXJnZSBpbnRvLlxuICogQHBhcmFtIHZhbHVlcyAtIFRoZSBzZXRzLlxuICovXG5mdW5jdGlvbiBtZXJnZVNldHNJbnRvKG1fdGFyZ2V0LCB2YWx1ZXMsIHV0aWxzLCBtZXRhKSB7XG4gICAgY29uc3QgYWN0aW9uID0gdXRpbHMubWVyZ2VGdW5jdGlvbnMubWVyZ2VTZXRzKG1fdGFyZ2V0LCB2YWx1ZXMsIHV0aWxzLCBtZXRhKTtcbiAgICBpZiAoYWN0aW9uID09PSBhY3Rpb25zSW50by5kZWZhdWx0TWVyZ2UpIHtcbiAgICAgICAgdXRpbHMuZGVmYXVsdE1lcmdlRnVuY3Rpb25zLm1lcmdlU2V0cyhtX3RhcmdldCwgdmFsdWVzKTtcbiAgICB9XG59XG4vKipcbiAqIE1lcmdlIG1hcHMgaW50byBhIHRhcmdldCBtYXAuXG4gKlxuICogQHBhcmFtIG1fdGFyZ2V0IC0gVGhlIHRhcmdldCB0byBtZXJnZSBpbnRvLlxuICogQHBhcmFtIHZhbHVlcyAtIFRoZSBtYXBzLlxuICovXG5mdW5jdGlvbiBtZXJnZU1hcHNJbnRvKG1fdGFyZ2V0LCB2YWx1ZXMsIHV0aWxzLCBtZXRhKSB7XG4gICAgY29uc3QgYWN0aW9uID0gdXRpbHMubWVyZ2VGdW5jdGlvbnMubWVyZ2VNYXBzKG1fdGFyZ2V0LCB2YWx1ZXMsIHV0aWxzLCBtZXRhKTtcbiAgICBpZiAoYWN0aW9uID09PSBhY3Rpb25zSW50by5kZWZhdWx0TWVyZ2UpIHtcbiAgICAgICAgdXRpbHMuZGVmYXVsdE1lcmdlRnVuY3Rpb25zLm1lcmdlTWFwcyhtX3RhcmdldCwgdmFsdWVzKTtcbiAgICB9XG59XG4vKipcbiAqIE1lcmdlIG90aGVyIHRoaW5ncyBpbnRvIGEgdGFyZ2V0LlxuICpcbiAqIEBwYXJhbSBtX3RhcmdldCAtIFRoZSB0YXJnZXQgdG8gbWVyZ2UgaW50by5cbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgb3RoZXIgdGhpbmdzLlxuICovXG5mdW5jdGlvbiBtZXJnZU90aGVyc0ludG8obV90YXJnZXQsIHZhbHVlcywgdXRpbHMsIG1ldGEpIHtcbiAgICBjb25zdCBhY3Rpb24gPSB1dGlscy5tZXJnZUZ1bmN0aW9ucy5tZXJnZU90aGVycyhtX3RhcmdldCwgdmFsdWVzLCB1dGlscywgbWV0YSk7XG4gICAgaWYgKGFjdGlvbiA9PT0gYWN0aW9uc0ludG8uZGVmYXVsdE1lcmdlIHx8IG1fdGFyZ2V0LnZhbHVlID09PSBhY3Rpb25zSW50by5kZWZhdWx0TWVyZ2UpIHtcbiAgICAgICAgdXRpbHMuZGVmYXVsdE1lcmdlRnVuY3Rpb25zLm1lcmdlT3RoZXJzKG1fdGFyZ2V0LCB2YWx1ZXMpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgZGVlcG1lcmdlLCBkZWVwbWVyZ2VDdXN0b20sIGRlZXBtZXJnZUludG8sIGRlZXBtZXJnZUludG9DdXN0b20sIGdldEtleXMsIGdldE9iamVjdFR5cGUsIG9iamVjdEhhc1Byb3BlcnR5IH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../node_modules/deepmerge-ts/dist/index.mjs\n");

/***/ })

};
;